//
// Created by tester on 12.05.2020.
//

#include "HashTable.h"

const char *POISON = "POISON";  //???????? ????????

List_t ListInit (size_t size) {
    List_t list = {};
    //????????? ?????? ??? ??????????? ??????
    list.items = (List_it *) calloc (size, sizeof(List_t));
    assert (list.items);

    list.size = 0;
    list.head = list.tail = 0;
    list.free = 1;

    list.items[0].data = (char *)POISON; //????????? ??????
    list.items[0].next = list.items[0].prev = 0; //????????? ???? ?? ????

    //?????????? ?????? ?????? ?????
    for (size_t idx = 1; idx < LIST_SIZE; ++idx) {
        list.items[idx].next = (idx + 1) % LIST_SIZE;
        list.items[idx].prev = (idx - 1) % LIST_SIZE;
    }
    ListOK (&list);
    return list;
}

void ListDestruct (List_t *list) {
    ListOK (list);
    list->size = 0;
    list->head = list->tail = 0;
    list->free = 1;

    //???????????? ??????, ?????????? ??? ?????????? ?????? ? ????????? ????????? ?? ?????????? ??????
    free (list->items);
    list->items = nullptr;
}

void ListOK (List_t *list) {
    return;
    if (list->free == 0)
        printf ("WARNING! List overflow!\n");

    //???????? ????????? ??????
    assert (list->items[0].prev == 0);
    assert (list->items[0].next == 0);
    assert (list->items[0].data == POISON);

    assert (list->items != nullptr); //???????? ????????? ?? ??????
    assert (list->head != list->free); //???????? head
    assert (list->items[list->head].prev == 0);
    assert (list->tail != list->free); //???????? tail
    assert (list->items[list->tail].next == 0);
    assert (list->dump_count > 0); //???????? ???????? ??????

    //???????? ????? ?????? ? ?????? ???????????
    size_t size = 0;
    for (size_t idx = list->head; idx != 0; idx = list->items[idx].next, ++size);
    assert (list->size == size);

    //???????? ????? ?????? ? ???????? ???????????
    size = 0;
    for (size_t idx = list->tail; idx != 0; idx = list->items[idx].prev, ++size);
    assert (list->size == size);

    //???? ??????
    //ListDump (list);
}

size_t ListValSearch (List_t *list, Elem_t val) {
    //????? ?? ???? ????????? ??????
    for (size_t idx = list->head; idx != 0; idx = list->items[idx].next) {
        //if (list->items[idx].data == val)

        char *temp = list->items[idx].data;
        char res = 0;
        /*asm(
            "	.intel_syntax_noprefix\n\t"
            "	mov rsi, [v]\n\t"
            "	mov rdi, [t]\n\t"
            "	mov al, 0h\n\t"
            ".for:\n\t"
            "	cmp byte ptr rsi, rdi\n\t"
            "	jne case_ne\n\t"
            "	cmp byte ptr rsi, al\n\t"
            "	je case_e\n\t"
            "	jmp .for\n\t"
            ".case_ne:\n\t"
            "	mov r, 0h\n\t"
            "	jmp .end\n\t"
            ".case_e:\n\t"
            "	mov r, 1h\n\t\n\t"
            "	.att_syntax_prefix\n\t"
            ".end\n\t"
            "	ret\n\t"

            :"+v" (val), "+t" (temp)
            :"r" (res)
            :"%rsi", "%rdi"
        );*/
        /*
        if (strcmp (val, list->items[idx].data) == 0)
            return idx;
        */
        if (res == 1)
            return idx;
    }
    return 0;
}

size_t ListIdxSearch (List_t *list, size_t idx_s) {
    size_t idx = list->head;

    for (size_t num = 0 ; num != idx_s; idx = list->items[idx].next, ++num) {
        if (idx == 0) //???? ???? ?????? ??????? ? ??????? ?? ??????
            return 0;
    }
    return idx; //??????????? ??????????? ?????? ????????
}

void ListPushBefore (List_t *list, Elem_t val_s, Elem_t val_i) {
    ListOK (list);
    //????????? ???????? ? ?????? ????????? ????????? ??????
    size_t cur = list->free;
    list->items[cur].data = val_i;
    list->free = list->items[cur].next;
    ++list->size; //??????????? ?????? ??????
    //????? ?????????? ?? ?????? ????????
    size_t idx_after = ListValSearch(list, val_s);
    if (!idx_after) {
        printf("Element %s not found\n", val_s);
        exit(1);
    }
    //???? ???????? ? ????? ??????
    if (idx_after == list->head)
        list->head = cur;
    //???? ???????? ?? ? ????? ??????, ?? ???????? ????????? ?? ????. ??????? ? ???????????
    if (list->items[idx_after].prev != 0)
        list->items[list->items[idx_after].prev].next = cur;
    //????????? ???????? ? ?????????? ?????????
    list->items[cur].prev = list->items[idx_after].prev;
    list->items[idx_after].prev = cur;
    list->items[cur].next = idx_after;
    ListOK (list);
}

void ListPushAfter (List_t *list, Elem_t val_s, Elem_t val_i) {
    ListOK (list);
    //????????? ???????? ? ?????? ????????? ????????? ??????
    size_t cur = list->free;
    list->items[cur].data = val_i;
    list->free = list->items[cur].next;
    ++list->size; //??????????? ?????? ??????
    //????? ??????????? ????????
    size_t idx_before = ListValSearch(list, val_s);
    if (!idx_before) {
        printf("Element %s not found\n", val_s);
        exit(1);
    }
    //???? ???????? ? ????? ?????
    if (idx_before == list->tail)
        list->tail = cur;
    //???? ???????? ?? ? ????? ?????, ?? ???????? ????????? ?? ????. ??????? ? ??????????
    if (list->items[idx_before].next != 0)
        list->items[list->items[idx_before].next].prev = cur;
    //????????? ???????? ? ??????????? ?????????
    list->items[cur].next = list->items[idx_before].next;
    list->items[idx_before].next = cur;
    list->items[cur].prev = idx_before;
    ListOK (list);
}

void ListDelete (List_t *list, Elem_t val) {
    ListOK (list);
    //????? ?????????? ????????
    size_t cur = ListValSearch(list, val);
    //?????????????? ????????? ??????? ? ???????????
    if (list->items[cur].prev != 0)
        list->items[list->items[cur].prev].next = list->items[cur].next;
    //?????????????? ?????????? ??????? ? ??????????
    if (list->items[cur].next != 0)
        list->items[list->items[cur].next].prev = list->items[cur].prev;
    --list->size; //????????? ?????? ??????

    //?????????? ?????? ? ?????
    if (list->head == cur)
        list->head = list->items[cur].next;
    else if (list->tail == cur)
        list->tail = list->items[cur].prev;

    //?????? ?????? ??? ????????? ??????? ? ?????? ?????? ?????? ?????????
    list->items[cur].next = list->free;
    list->free = cur;
    ListOK (list);
}

void ListClear (List_t *list) {
    ListOK (list);
    //???????? ????????? ???????? ???????? ??????
    size_t dump_count = list->dump_count;
    //?????????? ? ?????? ??????? ??????
    ListDestruct (list);
    *list = ListInit (LIST_SIZE);
    //?????????? ?????????? ???????? ???????? ??????
    list->dump_count = dump_count;
    ListOK (list);
}

void ListPushFront (List_t *list, Elem_t val) {
    ListOK (list);
    //????????? ???????? ? ?????? ????????? ????????? ??????
    size_t cur = list->free;
    list->items[cur].data = val;
    list->free = list->items[cur].next;
    ++list->size;
    //????????? ??????? ????????
    list->items[cur].prev = 0;
    list->items[cur].next = list->head;
    //???? ?? ????? ?????? ??? ??????
    if (list->head != 0)
        list->items[list->head].prev = cur;
    else //???? head == 0, ?? ? tail == 0
        list->tail = cur;
    list->head = cur;
    ListOK (list);
}

void ListPushBack (List_t *list, Elem_t val) {
    //ListOK (list);
    //????????? ???????? ? ?????? ????????? ????????? ??????
    size_t cur = list->free;
    list->items[cur].data = val;
    list->free = list->items[cur].next;
    ++list->size;
    //????????? ?????????? ????????
    list->items[cur].next = 0;
    list->items[cur].prev = list->tail;
    //???? ?? ????? ?????? ??? ??????
    if (list->tail != 0)
        list->items[list->tail].next = cur;
    else //???? tail == 0, ?? ? head == 0
        list->head = cur;
    list->tail = cur;
    //ListOK (list);
}

void ListPrint(List_t *list) {
    ListOK (list);
    printf ("This is ListPrint:\n"); //????????? ????? ??????????? ?????? ? ???????
    for (size_t idx = list->head; idx != 0; idx = list->items[idx].next) {
        printf ("%s ", list->items[idx].data);
    }
    printf ("\n");
}

void ListDump (List_t *list) {
    //???? ? ???????
    printf ("-------");

    for (size_t idx = 0; idx < LIST_SIZE; ++idx)
        printf ("----------");
    printf ("\n");

    printf ("HEAD: %zu, TAIL: %zu, SIZE: %zu, FREE: %zu\n", list->head, list->tail, list->size, list->free);

    printf ("-------");

    for (size_t idx = 0; idx < LIST_SIZE; ++idx)
        printf ("----------");
    printf ("\n");

    printf (" idx: ");
    for (size_t idx = 0; idx < LIST_SIZE; ++idx)
        printf ("%10zu", idx);
    printf ("\n");

    printf ("-------");

    for (size_t idx = 0; idx < LIST_SIZE; ++idx)
        printf ("----------");
    printf ("\n");

    printf ("prev: ");
    for (size_t idx = 0; idx < LIST_SIZE; ++idx)
        printf ("%10zu", list->items[idx].prev);
    printf ("\n");

    printf ("data: ");
    for (size_t idx = 0; idx < LIST_SIZE; ++idx)
        printf ("%10s", list->items[idx].data);
    printf ("\n");

    printf ("next: ");
    for (size_t idx = 0; idx < LIST_SIZE; ++idx)
        printf ("%10zu", list->items[idx].next);
    printf ("\n");

    printf ("\n");
    //????????? ????? ? ???????

    //?????? ? dot ???? (????????????? ?????)
    FILE *Dot = fopen ("../temp.dot", "w");
    fprintf (Dot, "digraph {\nnode [shape=\"box\"]\n"
                  "edge [style=\"dashed\" dir=\"both\"]\n"
                  "dirtype = \"both\"\n"
                  "rankdir=\"LR\"\n");

    //?????? ???? ????????? ?????? ? dot ????
    for (size_t idx = list->head; idx != 0; idx = list->items[idx].next) {
        fprintf (Dot, "\telem_%zu [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"3\">\n"
                      "\t\t<TR><TD COLSPAN=\"2\" BGCOLOR=\"white\"> idx: %zu </TD></TR>\n"
                      "\t\t<TR><TD COLSPAN=\"2\" BGCOLOR=\"white\"> data: %s </TD></TR>\n"
                      "\t\t<TR><TD BGCOLOR=\"salmon\" PORT=\"prev\"> prev: %lu </TD>\n"
                      "\t\t<TD BGCOLOR=\"lawngreen\" PORT=\"next\"> next: %lu </TD></TR>\n"
                      "\t</TABLE>>]\n", idx, idx, list->items[idx].data,
                 list->items[idx].prev == 0 ? -1 : list->items[idx].prev,
                 list->items[idx].next == 0 ? -1 : list->items[idx].next);
    }
    //???? ?????? ??????
    if (list->head != 0)
        fprintf (Dot, "\"data\" -> elem_%zu\n", list->head);
    else
        fprintf (Dot, "\"data\" -> \"empty\"\n");
    for (size_t idx = list->head; list->items[idx].next != 0; idx = list->items[idx].next)
        fprintf (Dot, "elem_%zu -> elem_%zu\n", idx, list->items[idx].next);

    //?????? ????????? ????? ? dot ????
    for (size_t idx = list->free; idx != 0; idx = list->items[idx].next) {
        fprintf (Dot, "\telem_free_%zu [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"3\">\n"
                      "\t\t<TR><TD COLSPAN=\"2\" BGCOLOR=\"aquamarine\"> idx: %zu </TD></TR>\n"
                      "\t\t<TR><TD COLSPAN=\"2\" BGCOLOR=\"aquamarine\"> data: %s </TD></TR>\n"
                      "\t\t<TR><TD BGCOLOR=\"salmon\" PORT=\"prev\"> prev: %lu </TD>\n"
                      "\t\t<TD BGCOLOR=\"lawngreen\" PORT=\"next\"> next: %lu </TD></TR>\n"
                      "\t</TABLE>>]\n", idx, idx, list->items[idx].data,
                 list->items[idx].prev == 0 ? -1 : list->items[idx].prev,
                 list->items[idx].next == 0 ? -1 : list->items[idx].next);
    }
    //???? ?????? ?? ????????
    if (list->free != 0)
        fprintf (Dot, "\"free\" -> elem_free_%zu\n", list->free);
    else
        fprintf (Dot, "\"free\" -> \"empty\"\n");
    for (size_t idx = list->free; list->items[idx].next != 0; idx = list->items[idx].next)
        fprintf (Dot, "elem_free_%zu -> elem_free_%zu\n", idx, list->items[idx].next);

    fprintf (Dot, "}\n");
    fclose (Dot);
    //????????? ????? ? dot ????

    //???????? gif ???????????
    char *command = (char *) calloc (NUM_SIZE + SERVICE, sizeof (char));
    sprintf (command, "dot -Tpng /home/biscuitslayer/CLionProjects/6_HashTable/temp.dot "
                      "-o/home/biscuitslayer/CLionProjects/6_HashTable/images/temp%zu.png", list->dump_count);

    //???? ????????? ???????? ??????, ????? ? ????????????? ?????????
    if (list->dump_count == 1)
        system ("rm /home/biscuitslayer/CLionProjects/6_HashTable/images/*");
    system (command);

    //???????????? ?????? ?? ??????? ? ?????????? ???????? ?????
    free (command);
    ++list->dump_count;
}

void ListSort (List_t *list) {
    ListOK(list);
    //???????? ??????? ? ??????????????? ??????????
    Elem_t *sorted_list_data = (Elem_t *) calloc(list->size, sizeof(Elem_t));

    //??????????? ???????????????? ?????? ? ??????
    for (size_t idx = list->head, sorted_idx = 0; idx != 0; idx = list->items[idx].next, ++sorted_idx)
        sorted_list_data[sorted_idx] = list->items[idx].data;

    //?????????? ???????? ? ??????????? ??????
    for (size_t idx = 1; idx < LIST_SIZE; ++idx) {
        list->items[idx].next = (idx + 1) % LIST_SIZE;
        list->items[idx].prev = (idx - 1) % LIST_SIZE;
        if (idx <= list->size)
            list->items[idx].data = sorted_list_data[idx - 1];
        else
            list->items[idx].data = 0;
    }

    //?????????? ??????
    free(sorted_list_data);

    //????????? ???????????????? ??????
    list->head = 1;
    list->tail = list->size;
    list->items[list->size].next = 0;
    list->free = list->size + 1;
    ListOK(list);
}

HT_t HTInit (size_t size) {
    HT_t ht = {};
    ht.lists = (List_t *) calloc (size, sizeof (List_t));
    ht.sizes = (size_t *) calloc (size, sizeof (size_t));
    return ht;
}

void HTDestruct (HT_t *ht) {
    for (int i = 0; i < HT_SIZE; ++i)
        ListDestruct (&ht->lists[i]);
    free (buf_to_free);
    free (ht->sizes);
    free (ht->lists);
}

void ReadData (HT_t *ht, FILE *readfile, unsigned long int (*HF) (char *str)) {
    struct stat file_info = {};
    stat (FILEPATH, &file_info);
    char *buf = GetWordsNum (readfile, file_info);
    buf_to_free = buf;
    for (size_t idx = 0; idx < words_num; ++idx) {
        HTInsert (ht, HF, buf);
        while (*buf != '\0')
            ++buf;
        if (idx == words_num - 1)
            break;
        ++buf;
        while (isspace (*buf))
            ++buf;
    }
}

void PrintStart (FILE *writefile) {
    fprintf (writefile, "LIST_NUM");
    for (size_t idx = 0; idx < HT_SIZE; ++idx)
        fprintf (writefile, ",%zu", idx);
    fprintf (writefile, "\n");

}

void PrintData (HT_t *ht, FILE *writefile, char *name) {
    fprintf (writefile, "%s", name);
    for (size_t idx = 0; idx < HT_SIZE; ++idx)
        fprintf (writefile, ",%zu", ht->sizes[idx]);
    fprintf (writefile, "\n");
}

char *GetWordsNum (FILE *user_input, struct stat file_info) {
    char *buf = (char *) calloc (file_info.st_size + BUF_EXTRA_SIZE, sizeof (char)); //????? ?? ????? ????? ????????????
    fread (buf, sizeof(char), file_info.st_size, user_input); //???????? ????? ???????????? ? ?????

    size_t i = 0; //?????? ? ??????

    //??????? ???????? ?? ?????? ???????
    while (isspace (buf[i])) ++i;

    //????????? ????? ????????????
    for ( ; ( (i < file_info.st_size) && (buf[i] != EOF) ); ++i) {
        //????? ?????? ? ?????????
        if (buf[i] == '\n' || isspace (buf[i]))
            ++words_num, buf[i] = '\0';

        //??????? ???????? ? ?????? ????? ??????
        while ((isspace (buf[i]) || buf[i] == '\0') && (i < file_info.st_size - 1))
            ++i;

        //???? ???????? ????? ?????
        if (buf[i] == EOF) {
            ++words_num;
            break;
        }
        if ((i == file_info.st_size - 1) && (buf[i] != '\n')) {
            ++words_num;
        }
    }
    return buf;
}

void HTInsert (HT_t *ht, unsigned long int (*HF) (char *str), char *str) {
    unsigned long int code = HF (str);
    code %= HT_SIZE;
    List_t *list = &(ht->lists[code]);
    if (list->items == nullptr)
        *list = ListInit (LIST_SIZE);
    ListPushBack (list, str);
    ++ht->sizes[code];
}

bool HTSearch (HT_t *ht, char *str) {

    size_t temp = 0, i = 0;
    while (temp == 0 && i < HT_SIZE) {
        temp = ListValSearch (&ht->lists[i], str);
        ++i;
    }
    return temp != 0;
}

unsigned long int EQ1 (char *str) {
    //?????????? ???????
    return 1;
}

unsigned long int FirstLetter (char *str) {
    //?????????? ASCII ??? ??????? ???????
    return (unsigned long int) tolower (str[0]);
}

unsigned long int BesouIdentity (char *str) {
    //??????? ?????
    const int A = 54059, B = 76963, C = 86969, FIRSTH = 37;
    char *s = str;
    unsigned h = FIRSTH;
    while (*s) {
        h = (h * A) ^ (s[0] * B);
        s++;
    }
    return h % C;
}

unsigned long int RSHash (char *str) {
    unsigned int b    = 378551;
    unsigned int a    = 63689;
    unsigned int hash = 0;

    for(std::size_t i = 0; i < strlen(str); i++)
    {
        hash = hash * a + str[i];
        a    = a * b;
    }

    return (hash & 0x7FFFFFFF);
}

unsigned long int JSHash (char *str) {
    unsigned int hash = 1315423911;
    for(size_t i = 0; i < strlen(str); i++)
        hash ^= ((hash << 5) + str[i] + (hash >> 2));
    return (hash & 0x7FFFFFFF);
}

unsigned long int Len (char *str) {
    //?????????? ????? ??????
    return strlen (str);
}

unsigned long int HashLy(char *str) {
    unsigned int hash = 0;

    for(; *str; str++)
        hash = (hash * 1664525) + (unsigned char)(*str) + 1013904223;

    return hash;
}

unsigned long int Sum (char *str) {
    unsigned long int code = 0;
    char *c = str;
    while (*c++ != '\0')
        code += (int) *c;
    return code;
}

unsigned long int GNU_HASH (char *str)
{
    unsigned long int h = 5381;

    for (unsigned char c = *str; c != '\0'; c = *++str)
        h = h * 33 + c;

    return h;
}

unsigned long int MURMUR (char *str) {
    char *key = str;
    unsigned int len = strlen (str);

    const unsigned int m = 0x5bd1e995;
    const unsigned int seed = 0;
    const int r = 24;

    unsigned int h = seed ^ len;

    const unsigned char * data = (const unsigned char *) key;
    unsigned int k;

    while (len >= 4) {
        k  = data [0];
        k |= data [1] << 8;
        k |= data [2] << 16;
        k |= data [3] << 24;

        k *= m;
        k ^= k >> r;
        k *= m;

        h *= m;
        h ^= k;

        data += 4;
        len -= 4;
    }

    switch (len) {
        case 3:
            h ^= data [2] << 16;
        case 2:
            h ^= data [1] << 8;
        case 1:
            h ^= data [0];
            h *= m;
    };

    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;

    return h;
}

unsigned long int rol (unsigned long int v, unsigned long shift) {
    unsigned long s =  shift >=  0 ? shift % 32 : - ((-shift) % 32);
    return (v << s) | (v >> (32 - s) );
}

unsigned long int RolHash (char *str) {
    unsigned long int code = 0;
    char *c = str;
    while (*c++ != '\0') {
        code = rol (code, 1);
        code ^= (unsigned long int) *c;
    }
    return code;
}

unsigned long int CRC32 (char *str) {

    unsigned long len = strlen (str);
    unsigned long crc_table[256] = {};
    unsigned long crc = 0;
    for (int i = 0; i < 256; i++)
    {
        crc = i;
        for (int j = 0; j < 8; j++)
            crc = crc & 1 ? (crc >> 1) ^ 0xEDB88320UL : crc >> 1;
        crc_table[i] = crc;
    };
    crc = 0xFFFFFFFFUL;
    while (len--)
        crc = crc_table[(crc ^ *str++) & 0xFF] ^ (crc >> 8);
    return crc ^ 0xFFFFFFFFUL;
}

unsigned long int CRC32_opt1 (char *str) {

    unsigned long len = strlen (str);
    unsigned long crc_table[256] = {};
    unsigned long crc = 0;

    //CRC32_tablefill();

    crc = 0xFFFFFFFFUL;
    while (len--)
        crc = crc_table_opt1[(crc ^ *str++) & 0xFF] ^ (crc >> 8);
    return crc ^ 0xFFFFFFFFUL;
}

void CRC32_tablefill () {
    unsigned long crc = 0;

    for (int i = 0; i < 256; i++) {
        crc = i;
        for (int j = 0; j < 8; j++)
            crc = crc & 1 ? (crc >> 1) ^ 0xEDB88320UL : crc >> 1;
        crc_table_opt1[i] = crc;
    };
}